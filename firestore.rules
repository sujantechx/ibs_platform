rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --- HELPER FUNCTIONS ---
    // Safe helpers: always check request.auth != null before calling get()
    function isSignedIn() {
      return request.auth != null;
    }

    function getAuthUserDoc() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid));
    }

    function isApprovedUser() {
      return isSignedIn() && getAuthUserDoc().data.status == 'approved';
    }

    function isAdmin() {
      return isSignedIn() && getAuthUserDoc().data.role == 'admin';
    }

    // --- PUBLIC ACCESS FOR COURSE LIST ---
    match /courses/{courseId} {
      allow read;
      // Only admins can write courses
      allow create, update, delete: if isAdmin();
    }

    // --- PUBLIC ACCESS FOR VAISHNAV PURAN (READ-ONLY FOR PUBLIC) ---
    // Top-level puran collection: public read, admin-only writes.
    match /vaishnav_puran/{puranId} {
      allow read;
      allow create, update, delete: if isAdmin();
    }

    // Also support older/alternate collection name `puran` which your app logs show.
    match /puran/{puranId} {
      allow read;
      allow create, update, delete: if isAdmin();
    }

    // Nested content under vaishnav_puran (subjects, chapters, etc.)
    // Public read access; only admins may create/update/delete.
    match /vaishnav_puran/{puranId}/{document=**} {
      allow read;
      allow create, update, delete: if isAdmin();
    }

    // Nested content under `puran` as well
    match /puran/{puranId}/{document=**} {
      allow read;
      allow create, update, delete: if isAdmin();
    }

    // --- USER PROFILE & DEVICES ---
    match /users/{uid} {
      // A user can read their own user doc
      allow read: if isSignedIn() && request.auth.uid == uid;

      // A new user may create their own user document during signup
      allow create: if isSignedIn() && request.auth.uid == uid
                    && request.resource.data.role == 'student'
                    && request.resource.data.status == 'pending';

      // Users may only update a limited set of fields on their own doc (e.g. device tokens).
      // Admins may update any user document.
      allow update: if (isSignedIn() && request.auth.uid == uid && (
                        ('fcmToken' in request.resource.data) ||
                        ('activeToken' in request.resource.data)
                      )) || isAdmin();

      // Only admins can delete user documents.
      allow delete: if isAdmin();

      // Devices subcollection: users may read/write their own device docs; admins may read/write all.
      match /devices/{deviceId} {
        allow read: if isSignedIn() && request.auth.uid == uid;
        allow write: if (isSignedIn() && request.auth.uid == uid && isApprovedUser()) || isAdmin();
      }
    }

    // Notifications: admin writes, recipient or admin reads
    match /notifications/{notificationId} {
      allow create, update, delete: if isAdmin();
      allow read: if isAdmin() || (isSignedIn() && request.auth.uid == resource.data.userId);
    }

    // --- SECURE NESTED CONTENT (example for courses nested docs) ---
    match /courses/{courseId}/{document=**} {
      allow read: if isApprovedUser() && getAuthUserDoc().data.courseId == courseId;
      allow create, update, delete: if isAdmin();
    }

    // Results collection
    match /results/{documentId} {
      allow read: if isSignedIn() && request.auth.uid == resource.data.userId;
      allow create, update: if isSignedIn() && request.auth.uid == request.resource.data.userId;
      allow delete: if isAdmin();
    }

    // Fallback: deny by default (implicitly enforced)
  }
}
